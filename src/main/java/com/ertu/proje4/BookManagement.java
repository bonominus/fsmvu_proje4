/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JDialog.java to edit this template
 */
package com.ertu.proje4;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;


/**
 *
 * @author ergul
 */
public class BookManagement extends javax.swing.JDialog {

    /**
     * Creates new form BookManagement
     */
    public BookManagement(java.awt.Frame parent, boolean modal) {
        super(parent, modal);
        date_formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
        initComponents();
        // Adding tabel model listener to resize table when table's data changes
        this.model = (DefaultTableModel)booksTable.getModel();
        model.addTableModelListener(new TableModelListener() {
            @Override
            public void tableChanged(TableModelEvent e) {
                resizeCells();
            }
        });
        // Setting custom column renderer for "Availability" column to emphasize on... availability
        booksTable.getColumnModel().getColumn(6).setCellRenderer(new DueDateColumnRenderer());
        // Show all books without any filtering
        showBooks("");
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        availableChBox = new javax.swing.JCheckBox();
        categoryCBox = new javax.swing.JComboBox<>();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        editionSpinner = new javax.swing.JSpinner();
        jLabel3 = new javax.swing.JLabel();
        nameTF = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        authorTF = new javax.swing.JTextField();
        publisherTF = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();
        isbnTF = new javax.swing.JFormattedTextField();
        addButton = new javax.swing.JButton();
        updateButton = new javax.swing.JButton();
        deleteButton = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        booksTable = new javax.swing.JTable();
        refreshButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        availableChBox.setText("Only Available");
        availableChBox.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                availableChBoxItemStateChanged(evt);
            }
        });

        categoryCBox.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Unselected", "Religion", "Science", "Engineering", "Arts", "Literature", "History", "Philosophy" }));
        categoryCBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                categoryCBoxActionPerformed(evt);
            }
        });

        jLabel1.setText("Category:");

        jLabel2.setText("Edition:");

        editionSpinner.setModel(new javax.swing.SpinnerNumberModel(0, 0, null, 1));
        editionSpinner.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                editionSpinnerStateChanged(evt);
            }
        });

        jLabel3.setText("Name:");

        nameTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nameTFActionPerformed(evt);
            }
        });

        jLabel4.setText("Author:");

        jLabel5.setText("Publisher:");

        authorTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                authorTFActionPerformed(evt);
            }
        });

        publisherTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                publisherTFActionPerformed(evt);
            }
        });

        jLabel6.setText("ISBN-13:");

        isbnTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                isbnTFActionPerformed(evt);
            }
        });

        addButton.setText("ADD");
        addButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addButtonActionPerformed(evt);
            }
        });

        updateButton.setText("UPDATE");
        updateButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                updateButtonActionPerformed(evt);
            }
        });

        deleteButton.setText("DELETE");
        deleteButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                deleteButtonActionPerformed(evt);
            }
        });

        jPanel1.setLayout(new java.awt.BorderLayout());

        jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);

        booksTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Name", "Author", "ISBN-13", "Publisher", "Edition", "Category", "Availability", "UUID"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.Integer.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });
        booksTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
        jScrollPane1.setViewportView(booksTable);

        jPanel1.add(jScrollPane1, java.awt.BorderLayout.CENTER);

        refreshButton.setText("REFRESH");
        refreshButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                refreshButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 564, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 41, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 41, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel5)
                            .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(isbnTF)
                            .addComponent(publisherTF)
                            .addComponent(categoryCBox, 0, 197, Short.MAX_VALUE)
                            .addComponent(editionSpinner)
                            .addComponent(nameTF)
                            .addComponent(authorTF)))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(addButton, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(updateButton, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 168, Short.MAX_VALUE)
                            .addComponent(availableChBox, javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(deleteButton, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(refreshButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel3)
                            .addComponent(nameTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel4)
                            .addComponent(authorTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel5)
                            .addComponent(publisherTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel6)
                            .addComponent(isbnTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel1)
                            .addComponent(categoryCBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel2)
                            .addComponent(editionSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addComponent(availableChBox)
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(addButton, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(updateButton, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(deleteButton, javax.swing.GroupLayout.DEFAULT_SIZE, 58, Short.MAX_VALUE))
                            .addComponent(refreshButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    // Filter books by name when a query is entered
    private void nameTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nameTFActionPerformed
        // A query is entered
        if (!nameTF.getText().isBlank()) {
            // Search query and the column's data is turned to lowercase to simplify search
            name_query = " AND LOWER(name) LIKE CONCAT('%', LOWER('"
                    + nameTF.getText().toLowerCase() + "'), '%')";
            // All filters are passed to showBooks() because if they don't have any query, 
            // they will be empty(as shown in else case below) therefore not affecting the function
            // "WHERE 1 = 1" is passed to create a condition in query, so the function wouldn't break abruptly
            showBooks("WHERE 1 = 1" + name_query + author_query + category_query + availability_query +
                    edition_query + publisher_query + isbn_query);
        } else {
            // If the query is reverted, empty the query
            name_query = "";
            showBooks("WHERE 1 = 1" + name_query + author_query + category_query + availability_query +
                    edition_query + publisher_query + isbn_query);
        }
    }//GEN-LAST:event_nameTFActionPerformed
    // Filter books by author when a query is entered, works the same way nameTFActionPerformed does. The only change is column.
    private void authorTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_authorTFActionPerformed
        if (!authorTF.getText().isBlank()) {
            author_query = " AND LOWER(author) LIKE CONCAT('%', LOWER('"
                    + authorTF.getText().toLowerCase() + "'), '%')";
            showBooks("WHERE 1 = 1" + name_query + author_query + category_query + availability_query +
                    edition_query + publisher_query + isbn_query);
        } else {
            author_query = "";
            showBooks("WHERE 1 = 1" + name_query + author_query + category_query + availability_query +
                    edition_query + publisher_query + isbn_query);
        }
    }//GEN-LAST:event_authorTFActionPerformed
    // Filter books by publisher. Works the same way with authorTFActionPerformed and nameTFActionPerformed
    private void publisherTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_publisherTFActionPerformed
        if (!publisherTF.getText().isBlank()) {
            publisher_query = " AND LOWER(publisher) LIKE CONCAT('%', LOWER('"
                    + publisherTF.getText().toLowerCase() + "'), '%')";
            showBooks("WHERE 1 = 1" + name_query + author_query + category_query + availability_query +
                    edition_query + publisher_query + isbn_query);
        } else {
            publisher_query = "";
            showBooks("WHERE 1 = 1" + name_query + author_query + category_query + availability_query +
                    edition_query + publisher_query + isbn_query);
        }
    }//GEN-LAST:event_publisherTFActionPerformed
    
    // Filter books by ISBN number. Works the same way with above functions.
    private void isbnTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_isbnTFActionPerformed
        if (!isbnTF.getText().isBlank()) {
            isbn_query = " AND isbn LIKE CONCAT('%', '"
                    + isbnTF.getText().toLowerCase() + "', '%')";
            showBooks("WHERE 1 = 1" + name_query + author_query + category_query + availability_query +
                    edition_query + publisher_query + isbn_query);
        } else {
            isbn_query = "";
            showBooks("WHERE 1 = 1" + name_query + author_query + category_query + availability_query +
                    edition_query + publisher_query + isbn_query);
        }
    }//GEN-LAST:event_isbnTFActionPerformed
    
    // Filter books by category
    private void categoryCBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_categoryCBoxActionPerformed
        // Get selected value of comboBox
        String selected_value = (String)categoryCBox.getSelectedItem();
        // If the value isn't "Unselected", then it is a query. The rest is the same as above functions.
        if (!selected_value.equals("Unselected")) {
            category_query = " AND category = '"
                    + selected_value + "'";
            showBooks("WHERE 1 = 1" + name_query + author_query + category_query + availability_query +
                    edition_query + publisher_query + isbn_query);
        } else {
            category_query = "";
            showBooks("WHERE 1 = 1" + name_query + author_query + category_query + availability_query +
                    edition_query + publisher_query + isbn_query);
        }
    }//GEN-LAST:event_categoryCBoxActionPerformed
    // Filter books by edition. Works the same way categoryCBoxActionPerformed does but it is a JSpinner this time.
    private void editionSpinnerStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_editionSpinnerStateChanged
        // Get the selected value from spinner
        Integer selected_value = (Integer)editionSpinner.getValue();
        // If the value isn't zero, then it is a query
        if (selected_value != 0) {
            edition_query = " AND edition = "
                    + selected_value;
            showBooks("WHERE 1 = 1" + name_query + author_query + category_query + availability_query +
                    edition_query + publisher_query + isbn_query);
        } else {
            edition_query = "";
            showBooks("WHERE 1 = 1" + name_query + author_query + category_query + availability_query +
                    edition_query + publisher_query + isbn_query);
        }
    }//GEN-LAST:event_editionSpinnerStateChanged
    // Filter books by availability. Shows only the available books when checked
    private void availableChBoxItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_availableChBoxItemStateChanged
        // If the check box is selected, then filter the books
        if (evt.getStateChange() == java.awt.event.ItemEvent.SELECTED) {
            availability_query = " AND duedate IS NULL";
            showBooks("WHERE 1 = 1" + name_query + author_query + category_query + availability_query +
                    edition_query + publisher_query + isbn_query);
        } else {
        // Reverse the filter when the box is unchecked    
            availability_query = "";
            showBooks("WHERE 1 = 1" + name_query + author_query + category_query + availability_query +
                    edition_query + publisher_query + isbn_query);
        }
    }//GEN-LAST:event_availableChBoxItemStateChanged

    private void addButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addButtonActionPerformed
        // Redirect to book registration form
        BookRegister book_registrar = new BookRegister((JFrame)this.getOwner(), true);
        book_registrar.setLocationRelativeTo(this);
        book_registrar.setVisible(true);
    }//GEN-LAST:event_addButtonActionPerformed

    private void refreshButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_refreshButtonActionPerformed
        // Empty all the fields and show all books
        nameTF.setText("");
        authorTF.setText("");
        isbnTF.setText("");
        publisherTF.setText("");
        categoryCBox.setSelectedIndex(0);
        editionSpinner.setValue(0);
        showBooks("");
    }//GEN-LAST:event_refreshButtonActionPerformed

    private void updateButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_updateButtonActionPerformed
        int selected_row = booksTable.getSelectedRow();
        // If the admin indeed selected a row...
        if (selected_row != -1) {
            // Get the book's complete data
            String book_name = (String)model.getValueAt(selected_row, 0);
            String book_author = (String)model.getValueAt(selected_row, 1);
            String book_isbn = (String)model.getValueAt(selected_row, 2);
            String book_publisher = (String)model.getValueAt(selected_row, 3);
            Integer book_edition = (Integer)model.getValueAt(selected_row, 4);
            String book_category = (String)model.getValueAt(selected_row, 5);
            
            String book_due_date = (String)model.getValueAt(selected_row, 6);
            String book_due_date_arg = book_due_date.equals("Available") ? null : book_due_date;
            
            String book_uuid = (String)model.getValueAt(selected_row, 7);
            
            // Redirect to the frame for book information updates with the widgets' initial texts set
            BookUpdate book_updater = new BookUpdate((JFrame)this.getOwner(), true, book_name, book_author, book_category,
                    book_publisher, book_edition, book_isbn, book_due_date_arg, book_uuid);
            book_updater.setLocationRelativeTo(this);
            book_updater.setVisible(true);
        } else {
            JOptionPane.showMessageDialog(this, "You need to select a book first!",
                    "Error!", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_updateButtonActionPerformed

    private void deleteButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deleteButtonActionPerformed
        int selected_row = booksTable.getSelectedRow();
        // If the admin indeed selected a book...
        if (selected_row != -1) {
            // Get book's unique identifier
            String book_uuid = (String)booksTable.getValueAt(selected_row, 7);
            
            try (Connection conn = DriverManager.getConnection(DBCredentials.db_url, DBCredentials.db_username,
                    DBCredentials.db_password)) {
                // Search for the book with the identifier and delete it
                String query = "DELETE FROM books WHERE uuid = ?";
                
                try (PreparedStatement statement = conn.prepareStatement(query)) {
                    statement.setString(1, book_uuid);
                    
                    int result = statement.executeUpdate();
                    // Inform the admin about success or failure
                    if (result > 0) {
                        JOptionPane.showMessageDialog(this, "Deleted book successfully.");
                    } else {
                        JOptionPane.showMessageDialog(this, "Failed to delete the book.", "Warning!",
                                JOptionPane.WARNING_MESSAGE);
                    }
                }
            } catch (SQLException ex) {
                JOptionPane.showMessageDialog(this, ex.getMessage(),
                            "Database error!", JOptionPane.ERROR_MESSAGE);
            }
        }
    }//GEN-LAST:event_deleteButtonActionPerformed

    private void showBooks(String search) {
        // Empty the table
        model.setRowCount(0);
        try (Connection conn = DriverManager.getConnection(DBCredentials.db_url, DBCredentials.db_username,
                DBCredentials.db_password)) {
            // Select the books from db with the parameters set in query
            String query = "SELECT * FROM books " + search;
            
            try (PreparedStatement statement = conn.prepareStatement(query)) {
                ResultSet result_set = statement.executeQuery();
                
                // Iterating through all the books retrieved
                while (result_set.next()) {
                    // Get the book's data
                    String book_name = result_set.getString("name");
                    String book_author = result_set.getString("author");
                    String book_isbn = result_set.getString("isbn");
                    String book_publisher = result_set.getString("publisher");
                    int book_edition = result_set.getInt("edition");
                    String book_uuid = result_set.getString("uuid");
                    String book_category = result_set.getString("category");
                    
                    java.sql.Date book_date = result_set.getDate("duedate");
                    String book_date_str;
                    // Create a string to explain the book's availability to the user
                    if (book_date != null) {
                        // If it has a due date, convert it to a day/month/year string
                        LocalDate book_local_date = book_date.toLocalDate();
                        book_date_str = book_local_date.format(date_formatter);
                    } else {
                        book_date_str = "Available";
                    }
                    
                    // Add the book to table
                    model.addRow(new Object[]{book_name, book_author, book_isbn, book_publisher, book_edition,
                                                book_category, book_date_str, book_uuid});
                }
            }
        } catch (SQLException ex) {
            JOptionPane.showMessageDialog(this, ex.getMessage(),
                            "Database error!", JOptionPane.ERROR_MESSAGE);
        }
    }
    
    // This function is called every time the table's data changes so that table cells would be fully 
    // expanded to contained data's size
    private void resizeCells() {
        for (int column = 0; column < booksTable.getColumnCount(); column++) {
            TableColumn table_column = booksTable.getColumnModel().getColumn(column);
            int preferred_width = 0;

            // Consider column header width
            int headerWidth = booksTable.getTableHeader().getDefaultRenderer()
                    .getTableCellRendererComponent(booksTable, table_column.getHeaderValue(), false, false, -1, column)
                    .getPreferredSize().width;
            preferred_width = Math.max(preferred_width, headerWidth);

            // Consider cell widths
            for (int row = 0; row < booksTable.getRowCount(); row++) {
                int cellWidth = booksTable.getFontMetrics(booksTable.getFont())
                        .stringWidth(booksTable.getValueAt(row, column).toString());
                preferred_width = Math.max(preferred_width, cellWidth);
            }

            table_column.setPreferredWidth(preferred_width + 10);
        }
    }
    
    // This column renderer is used for "Availability" column to emphasize on the data
    private class DueDateColumnRenderer extends DefaultTableCellRenderer {

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,
                boolean hasFocus, int row, int column) {
            Component component = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

            // Set the font style to bold
            Font font = component.getFont();
            font = font.deriveFont(font.getStyle() | Font.BOLD);
            component.setFont(font);

            // Set different colors based on the cell value
            if (value != null) {
                String text = value.toString();
                if (text.equals("Available")) {
                    component.setForeground(Color.GREEN);
                } else {
                    component.setForeground(Color.RED);
                }
            }

            return component;
        }
    }

    private DefaultTableModel model;
    private DateTimeFormatter date_formatter;
    
    private String name_query = "";
    private String author_query = "";
    private String category_query = "";
    private String availability_query = "";
    private String edition_query = "";
    private String publisher_query = "";
    private String isbn_query = "";
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton addButton;
    private javax.swing.JTextField authorTF;
    private javax.swing.JCheckBox availableChBox;
    private javax.swing.JTable booksTable;
    private javax.swing.JComboBox<String> categoryCBox;
    private javax.swing.JButton deleteButton;
    private javax.swing.JSpinner editionSpinner;
    private javax.swing.JFormattedTextField isbnTF;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextField nameTF;
    private javax.swing.JTextField publisherTF;
    private javax.swing.JButton refreshButton;
    private javax.swing.JButton updateButton;
    // End of variables declaration//GEN-END:variables
}
